(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs'), require('rxjs/operators')) :
  typeof define === 'function' && define.amd ? define(['exports', 'rxjs', 'rxjs/operators'], factory) :
  (global = global || self, factory((global.ngx = global.ngx || {}, global.ngx.untilDestroyed = {}), global.rxjs, global.rxjs));
}(this, function (exports, rxjs, operators) { 'use strict';

  function isFunction(value) {
      return typeof value === 'function';
  }
  var UNTIL_DESTROYED_KEY = '__untilDestroyed__';
  function getDestroyedSubjectOn(instance, method) {
      var originalDestroy = instance[method];
      if (!isFunction(originalDestroy)) {
          throw new Error(instance.constructor.name + " is using untilDestroyed but doesn't implement " + method);
      }
      var destroyed$ = instance[UNTIL_DESTROYED_KEY];
      if (!destroyed$) {
          destroyed$ = new rxjs.Subject();
          Object.defineProperty(instance, UNTIL_DESTROYED_KEY, {
              configurable: true,
              enumerable: false,
              value: destroyed$,
          });
          instance[method] = function () {
              originalDestroy.apply(this, arguments);
              destroyed$.next();
              destroyed$.complete();
          };
      }
      return destroyed$;
  }
  /**
   * Unsubscribe from Observable when a Component/Class destroyed.
   *
   * @example
   * ```ts
   * @Component({...})
   * class MyComponent implements OnDestroy {
   *   stream$ = interval(100).pipe(untilDestroyed(this));
   *
   *   ngOnDestroy() {} // This method must be present on class
   * }
   * ```
   */
  function untilDestroyed(instance, destroyMethodName) {
      if (destroyMethodName === void 0) { destroyMethodName = 'ngOnDestroy'; }
      var destroyed$ = getDestroyedSubjectOn(instance, destroyMethodName);
      return function (source$) { return source$.pipe(operators.takeUntil(destroyed$)); };
  }

  /**
   * Automatically unsubscribes from pipe when component destroyed.
   *
   * @example
   * ```ts
   * @Component({...})
   * class MyComponent implements OnDestroy {
   *   @WithUntilDestroyed()
   *   stream$ = new Observable(...);
   *
   *   // OnDestroy method is required by Angular Compiler
   *   ngOnDestroy() {}
   * }
   * ```
   *
   * Uses {@link untilDestroyed} operator on the pipe.
   *
   * Do not forget to implement {@link OnDestroy} life-cycle hook.
   */
  function WithUntilDestroyed(destroyMethodName) {
      return function (target, propKey) {
          var valueKey = "__WithUntilDestroyed:" + String(propKey) + "__";
          function getter() {
              return this[valueKey];
          }
          function setter(newVal) {
              if (rxjs.isObservable(newVal)) {
                  delete this[valueKey];
                  Object.defineProperty(this, valueKey, {
                      configurable: true,
                      enumerable: false,
                      value: newVal.pipe(untilDestroyed(this, destroyMethodName)),
                  });
              }
              else {
                  throw Error("WithUntilDestroyed: Property " + String(propKey) + " on " + target.constructor.name + " is not Observable!");
              }
          }
          if (delete target[propKey]) {
              Object.defineProperty(target, propKey, {
                  enumerable: true,
                  configurable: true,
                  set: setter,
                  get: getter,
              });
          }
      };
  }

  exports.untilDestroyed = untilDestroyed;
  exports.WithUntilDestroyed = WithUntilDestroyed;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
