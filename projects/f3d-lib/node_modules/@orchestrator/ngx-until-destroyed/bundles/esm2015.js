import { Subject, isObservable } from 'rxjs';
import { takeUntil } from 'rxjs/operators';

function isFunction(value) {
    return typeof value === 'function';
}
const UNTIL_DESTROYED_KEY = '__untilDestroyed__';
function getDestroyedSubjectOn(instance, method) {
    const originalDestroy = instance[method];
    if (!isFunction(originalDestroy)) {
        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${method}`);
    }
    let destroyed$ = instance[UNTIL_DESTROYED_KEY];
    if (!destroyed$) {
        destroyed$ = new Subject();
        Object.defineProperty(instance, UNTIL_DESTROYED_KEY, {
            configurable: true,
            enumerable: false,
            value: destroyed$,
        });
        instance[method] = function () {
            originalDestroy.apply(this, arguments);
            destroyed$.next();
            destroyed$.complete();
        };
    }
    return destroyed$;
}
/**
 * Unsubscribe from Observable when a Component/Class destroyed.
 *
 * @example
 * ```ts
 * @Component({...})
 * class MyComponent implements OnDestroy {
 *   stream$ = interval(100).pipe(untilDestroyed(this));
 *
 *   ngOnDestroy() {} // This method must be present on class
 * }
 * ```
 */
function untilDestroyed(instance, destroyMethodName = 'ngOnDestroy') {
    const destroyed$ = getDestroyedSubjectOn(instance, destroyMethodName);
    return source$ => source$.pipe(takeUntil(destroyed$));
}

/**
 * Automatically unsubscribes from pipe when component destroyed.
 *
 * @example
 * ```ts
 * @Component({...})
 * class MyComponent implements OnDestroy {
 *   @WithUntilDestroyed()
 *   stream$ = new Observable(...);
 *
 *   // OnDestroy method is required by Angular Compiler
 *   ngOnDestroy() {}
 * }
 * ```
 *
 * Uses {@link untilDestroyed} operator on the pipe.
 *
 * Do not forget to implement {@link OnDestroy} life-cycle hook.
 */
function WithUntilDestroyed(destroyMethodName) {
    return function (target, propKey) {
        const valueKey = `__WithUntilDestroyed:${String(propKey)}__`;
        function getter() {
            return this[valueKey];
        }
        function setter(newVal) {
            if (isObservable(newVal)) {
                delete this[valueKey];
                Object.defineProperty(this, valueKey, {
                    configurable: true,
                    enumerable: false,
                    value: newVal.pipe(untilDestroyed(this, destroyMethodName)),
                });
            }
            else {
                throw Error(`WithUntilDestroyed: Property ${String(propKey)} on ${target.constructor.name} is not Observable!`);
            }
        }
        if (delete target[propKey]) {
            Object.defineProperty(target, propKey, {
                enumerable: true,
                configurable: true,
                set: setter,
                get: getter,
            });
        }
    };
}

export { untilDestroyed, WithUntilDestroyed };
