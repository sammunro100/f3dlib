import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
function isFunction(value) {
    return typeof value === 'function';
}
const UNTIL_DESTROYED_KEY = '__untilDestroyed__';
function getDestroyedSubjectOn(instance, method) {
    const originalDestroy = instance[method];
    if (!isFunction(originalDestroy)) {
        throw new Error(`${instance.constructor.name} is using untilDestroyed but doesn't implement ${method}`);
    }
    let destroyed$ = instance[UNTIL_DESTROYED_KEY];
    if (!destroyed$) {
        destroyed$ = new Subject();
        Object.defineProperty(instance, UNTIL_DESTROYED_KEY, {
            configurable: true,
            enumerable: false,
            value: destroyed$,
        });
        instance[method] = function () {
            originalDestroy.apply(this, arguments);
            destroyed$.next();
            destroyed$.complete();
        };
    }
    return destroyed$;
}
/**
 * Unsubscribe from Observable when a Component/Class destroyed.
 *
 * @example
 * ```ts
 * @Component({...})
 * class MyComponent implements OnDestroy {
 *   stream$ = interval(100).pipe(untilDestroyed(this));
 *
 *   ngOnDestroy() {} // This method must be present on class
 * }
 * ```
 */
export function untilDestroyed(instance, destroyMethodName = 'ngOnDestroy') {
    const destroyed$ = getDestroyedSubjectOn(instance, destroyMethodName);
    return source$ => source$.pipe(takeUntil(destroyed$));
}
//# sourceMappingURL=until-destroyed.js.map